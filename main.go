/*
Требования:
1) Калькулятор умеет выполнять операции сложения, вычитания, умножения и деления с двумя числами: a + b, a - b, a * b, a / b. Данные передаются в одну строку. Решения, в которых каждое число и арифметическая операция передаются с новой строки, считаются неверными.
2) Калькулятор умеет работать как с арабскими (1, 2, 3, 4, 5…), так и с римскими (I, II, III, IV, V…) числами.
3) Калькулятор должен принимать на вход числа от 1 до 10 включительно, не более. На выходе числа не ограничиваются по величине и могут быть любыми.
4) Калькулятор умеет работать только с целыми числами.
5) Калькулятор умеет работать только с арабскими или римскими цифрами одновременно, при вводе пользователем строки вроде 3 + II калькулятор должен выдать панику и прекратить работу.
6) При вводе римских чисел ответ должен быть выведен римскими цифрами, соответственно, при вводе арабских — ответ ожидается арабскими.
7) При вводе пользователем не подходящих чисел приложение выдаёт панику и завершает работу.
8) При вводе пользователем строки, не соответствующей одной из вышеописанных арифметических операций, приложение выдаёт панику и завершает работу.
9) Результатом операции деления является целое число, остаток отбрасывается.
10) Результатом работы калькулятора с арабскими числами могут быть отрицательные числа и ноль. Результатом работы калькулятора с римскими числами могут быть только положительные числа, если результат работы меньше единицы, программа должна выдать панику.
*/

/*
На текущий момент не выполняется 3 и 6 пункты. 
*/


package main

import (
	"fmt"
	"strconv"
	"strings"
)

// Преобразование римских чисел в арабские
func romanToInt(s string) (int, error) {
	romanNumerals := map[rune]int{
		'I': 1,
		'V': 5,
		'X': 10,
		'L': 50,
		'C': 100,
		'D': 500,
		'M': 1000,
	}

	total := 0
	prevValue := 0

	// Приводим входное значение к верхнему регистру
	s = strings.ToUpper(s)

	for _, char := range s {
		currentValue, exists := romanNumerals[char]
		if !exists {
			return 0, fmt.Errorf("недопустимый символ: %c", char)
		}

		// Если текущее значение больше предыдущего, значит мы попали в ситуацию, когда
		// нужно вычесть предыдущее значение (например, IV, IX и т.п.)
		if currentValue > prevValue {
			total += currentValue - 2*prevValue // Вычитаем двойное предыдущее значение
		} else {
			total += currentValue
		}
		prevValue = currentValue
	}

	return total, nil
}

func main() {
	input := make([]string, 4)
	fmt.Println("Введите строку в формате 'число операция число':")
	_, err := fmt.Scanln(&input[0], &input[1], &input[2])
	if err != nil {
		fmt.Println("Паника! Должно быть всего 2 аргумента и один знак операции", err)
		return
	}

	// Проверяем количество частей
	if input[3] != "" {
		fmt.Println(`Паника! Необходимо ввести строку в формате 'число операция число'`)
		return
	}
	// Преобразуем первое и третье поле в числа
	firstNumber, err1 := strconv.Atoi(input[0])
	secondNumber, err2 := strconv.Atoi(input[2])
	operand := input[1]
	if err1 != nil && err2 != nil {
		var arabic1, arabic2 int
		var result int
		arabic1, _ = romanToInt(input[0])
		arabic2, _ = romanToInt(input[2])
		result = arabic1
		switch operand {
		case "+":
			result += arabic2
		case "-":
			result -= arabic2
		case "/":
			result /= arabic2
		case "*":
			result *= arabic2
		case "default":
			fmt.Println("Паника! Нет такой операции.")
			return
		}
		if result >= 0 {
			fmt.Println(result)
			return
		} else {
			fmt.Println("Паника! Результат операции с римскими числами должен быть больше 0")
		}
	} else if !(err1 == nil && err2 == nil) {
		fmt.Println("Паника! Нужно указывать числа в одном формате. Оба числа арабские или оба числа римские")
	} else {
		result := firstNumber
		switch operand {
		case "+":
			result += secondNumber
		case "-":
			result -= secondNumber
		case "/":
			result /= secondNumber * 1.0
		case "*":
			result *= secondNumber
		case "default":
			fmt.Println("Паника! Нет такой операции.")
			return
		}
		fmt.Println(result)
	}
}
